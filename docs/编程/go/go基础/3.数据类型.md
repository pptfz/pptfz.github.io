





# 数据类型

## 1.基本数据类型

### 1.1 整型

**有符号整数和无符号整数类型表**

| 类型     | 位宽 (n) | 表示范围                    | 最小值表示（补码）                          | 最大正数表示（原码）                        | 备注             |
| -------- | -------- | --------------------------- | ------------------------------------------- | ------------------------------------------- | ---------------- |
| `int8`   | 8 位     | $(-2)^7$ 到 $2^7 - 1$       | `10000000 = -128`                           | `01111111 = 127`                            | 有符号 8 位整数  |
| `int16`  | 16 位    | $(-2)^{15}$ 到 $2^{15} - 1$ | `1000000000000000 = -32,768`                | `0111111111111111 = 32,767`                 | 有符号 16 位整数 |
| `int32`  | 32 位    | $(-2)^{31}$ 到 $2^{31} - 1$ | `10000000...0 = -2,147,483,648`             | `01111111...1 = 2,147,483,647`              | 有符号 32 位整数 |
| `int64`  | 64 位    | $(-2)^{63}$ 到 $2^{63} - 1$ | `10000000...0 = -9,223,372,036,854,775,808` | `01111111...1 = 9,223,372,036,854,775,807`  | 有符号 64 位整数 |
| `uint8`  | 8 位     | $0$ 到 $2^8 - 1$            | `00000000 = 0`                              | `11111111 = 255`                            | 无符号 8 位整数  |
| `uint16` | 16 位    | $0$ 到 $2^{16} - 1$         | `00000000...0 = 0`                          | `11111111...1 = 65,535`                     | 无符号 16 位整数 |
| `uint32` | 32 位    | $0$ 到 $2^{32} - 1$         | `00000000...0 = 0`                          | `11111111...1 = 4,294,967,295`              | 无符号 32 位整数 |
| `uint64` | 64 位    | $0$ 到 $2^{64} - 1$         | `00000000...0 = 0`                          | `11111111...1 = 18,446,744,073,709,551,615` | 无符号 64 位整数 |



如下代码可输出有符号和无符号整数范围

```go
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println("有符号整数范围:")
	fmt.Printf("int8:  [%d, %d]\n", math.MinInt8, math.MaxInt8)
	fmt.Printf("int16: [%d, %d]\n", math.MinInt16, math.MaxInt16)
	fmt.Printf("int32: [%d, %d]\n", math.MinInt32, math.MaxInt32)
	fmt.Printf("int64: [%d, %d]\n", math.MinInt64, math.MaxInt64)

	fmt.Println("\n无符号整数范围:")
	fmt.Printf("uint8:  [%d, %d]\n", 0, math.MaxUint8)
	fmt.Printf("uint16: [%d, %d]\n", 0, math.MaxUint16)
	fmt.Printf("uint32: [%d, %d]\n", 0, math.MaxUint32)

	// 无符号最大值 uint64 需显式转换为 uint64 类型
	const MaxUint64 = uint64(1<<64 - 1)
	fmt.Printf("uint64: [%d, %d]\n", 0, MaxUint64)
}
```

输出

```shell
有符号整数范围:
int8:  [-128, 127]
int16: [-32768, 32767]
int32: [-2147483648, 2147483647]
int64: [-9223372036854775808, 9223372036854775807]

无符号整数范围:
uint8:  [0, 255]
uint16: [0, 65535]
uint32: [0, 4294967295]
uint64: [0, 18446744073709551615]
```





#### 1.1.1 有符号整数

```go
package main

import "fmt"

func main() {
	// 有符号整数
	var i8 int8 = 127                   // -128 到 127
	var i16 int16 = 32767               // -32768 到 32767
	var i32 int32 = 2147483647          // -2147483648 到 2147483647
	var i64 int64 = 9223372036854775807 // -9223372036854775808 到 9223372036854775807
	var i int = 42                      // 32位或64位（取决于系统）

	_ = i // 使用 _ 忽略未使用的变量

	// byte 是 uint8 的别名
	var b byte = 255

	// rune 是 int32 的别名
	var r rune = '牛' // Unicode字符 只能为单个字符

	fmt.Printf("有符号整数类型示例：\n")
	fmt.Printf("int8: %d\n", i8)
	fmt.Printf("int16: %d\n", i16)
	fmt.Printf("int32: %d\n", i32)
	fmt.Printf("int64: %d\n", i64)
	fmt.Printf("byte: %d\n", b)
	fmt.Printf("rune: %c\n", r)
}
```

输出

```shell
有符号整数类型示例：
int8: 127
int16: 32767
int32: 2147483647
int64: 9223372036854775807
byte: 255
rune: 牛
```



#### 1.1.2 无符号整数

```go
package main

import "fmt"

func main() {
	// 无符号整数
	var ui8 uint8 = 255                    // 0 到 255
	var ui16 uint16 = 65535                // 0 到 65535
	var ui32 uint32 = 4294967295           // 0 到 4294967295
	var ui64 uint64 = 18446744073709551615 // 0 到 18446744073709551615
	var ui uint = 42                       // 32位或64位（取决于系统）

	_ = ui // 使用 _ 忽略未使用的变量

	// byte 是 uint8 的别名
	var b byte = 255

	// rune 是 int32 的别名
	var r rune = '牛' // Unicode字符 只能为单个字符

	fmt.Printf("无符号整数类型示例：\n")
	fmt.Printf("ui8: %d\n", ui8)
	fmt.Printf("ui16: %d\n", ui16)
	fmt.Printf("ui32: %d\n", ui32)
	fmt.Printf("ui64: %d\n", ui64)
	fmt.Printf("byte: %d\n", b)
	fmt.Printf("rune: %c\n", r)
}
```

输出

```shell
无符号整数类型示例：
ui8: 255
ui16: 65535
ui32: 4294967295
ui64: 18446744073709551615
byte: 255
rune: 牛
```



### 1.2 浮点型

:::tip 说明

`float32` 会将超出精度的数字被近似到最接近的可表示值

:::

| 特性              | float32                      | float64                          |
| ----------------- | ---------------------------- | -------------------------------- |
| **总位数**        | 32 位                        | 64 位                            |
| **符号位**        | 1 位                         | 1 位                             |
| **指数位**        | 8 位                         | 11 位                            |
| **尾数位**        | 23 位                        | 52 位                            |
| **偏移量 (Bias)** | 127                          | 1023                             |
| **指数范围**      | -126 到 +127                 | -1022 到 +1023                   |
| **最大值**        | ≈ 3.4 × 10³⁸                 | ≈ 1.8 × 10³⁰⁸                    |
| **最小次正规值**  | ≈ 1.18 × 10⁻³⁸               | ≈ 2.23 × 10⁻³⁰⁸                  |
| **有效数字精度**  | 大约 7 位十进制              | 大约 15-16 位十进制              |
| **内存占用**      | 4 字节                       | 8 字节                           |
| **适用场景**      | 内存和效率优先，如游戏开发等 | 高精度需求，如科学计算和金融分析 |



代码示例

```go
package main

import "fmt"

func main() {
	var f32 float32 = 1.12345678901234567890 // float32 精度限制
	var f64 float64 = 1.12345678901234567890 // float64 精度更高

	fmt.Println("float32:", f32) // float32精确到小数点后7位 1.1234567 输出近似值即1.1234568
	fmt.Println("float64:", f64) // float64精确到小数点后16位 1.1234567890123456 输出近似值1.1234567890123457
}
```

输出

```shell
float32: 1.1234568
float64: 1.1234567890123457
```



### 1.3 复数型

:::tip 说明

在 Go 语言中，**复数**是一种内置的数据类型，使用 `complex64` 和 `complex128` 表示。它们由两个部分组成：**实部**和**虚部**，均为浮点数

:::

**复数类型**

- **`complex64`**：实部和虚部都是 `float32`
- **`complex128`**：实部和虚部都是 `float64`



**创建复数**

```go
package main

import "fmt"

func main() {
  
  // 方法1，通过 complex 函数定义，定义一个实部为3，虚部为4的复数
	c1 := complex(3, 4)
  
  // 方法2，直接通过字面量定义，定义一个实部为3，虚部为4的复数
	c2 := 3 + 4i
  
  // 方法3，通过关键字定义
  var c64 complex64 = 3.14 + 2.7i   // 由两个float32组成
	var c128 complex128 = 3.14 + 2.7i // 由两个float64组成
  
  fmt.Printf("复数类型示例：\n")
  fmt.Printf("c1: %v\n", c1)
  fmt.Printf("c2: %v\n", c2)
	fmt.Printf("complex64: %v\n", c64)
	fmt.Printf("complex128: %v\n", c128)
	fmt.Printf("real部分: %f\n", real(c64))
	fmt.Printf("imag部分: %f\n", imag(c64))
}
```

输出

```shell
复数类型示例：
c1: (3+4i)
c2: (3+4i)
complex64: (3.14+2.7i)
complex128: (3.14+2.7i)
real部分: 3.140000
imag部分: 2.700000
```



**获取实部和虚部**

```go
package main

import "fmt"

func main() {
	c1 := complex(3, 4)
	//c2 := 3 + 4i
	fmt.Println(real(c1)) // 输出3
	fmt.Println(imag(c1)) // 输出4
}
```

输出

```shell
3
4
```



**复数运算**

:::tip 复数乘法

复数乘法的核心是：

实部通过两个实部相乘减去两个虚部相乘
虚部通过交叉相乘再相加

实部
5x3 - 6x4 = -9

虚部
5x4 + 3x6 = 38i

:::

:::tip 复数除法

定义的复数为：

- $a = 5 + 6i$ 
  其中：
  - 实部：$a_\text{real} = 5$
  - 虚部：$b_\text{imag} = 6$

- $b = 3 + 4i$ 
  其中：
  - 实部：$c_\text{real} = 3$
  - 虚部：$d_\text{imag} = 4$

对于复数 $a + bi$ 和 $c + di$，其商的公式为：

$$
\frac{a + bi}{c + di} = \frac{(ac + bd)}{c^2 + d^2} + \frac{(bc - ad)}{c^2 + d^2}i
$$


详细计算过程

1.分母
$$
c^2 + d^2 = 3^2 + 4^2 = 9 + 16 = 25
$$
2.分子
$$
(a + bi) \cdot (c - di) = (ac + bd) + (bc - ad)i = (5 \cdot 3 + 6 \cdot 4) + (6 \cdot 3 - 5 \cdot 4)i = (15 + 24) + (18 - 20)i = 39 - 2i
$$


分解计算

- 实部
  $$
  ac + bd = (5 \cdot 3) + (6 \cdot 4) = 15 + 24 = 39
  $$

- 虚部
  $$
  bc - ad = (6 \cdot 3) - (5 \cdot 4) = 18 - 20 = -2
  $$



分子为
$$
39 - 2i
$$
商
$$
\frac{39 - 2i}{25} = \frac{39}{25} + \frac{-2}{25}i
$$


化简
$$
1.56 - 0.08i
$$
最终结果
$$
\frac{5 + 6i}{3 + 4i} = 1.56 - 0.08i
$$
:::

```go
package main

import (
	"fmt"
)

func main() {
	a := complex(5, 6)
	b := 3 + 4i

	fmt.Println("a:", a)
	fmt.Println("b:", b)
	fmt.Println("实部 a:", real(a))
	fmt.Println("虚部 a:", imag(a))

	// 复数运算
	fmt.Println("加法:", a+b)
	fmt.Println("减法:", a-b)
	fmt.Println("乘法:", a*b)
	fmt.Println("除法:", a/b)
}
```

输出

```shell
a: (5+6i)
b: (3+4i)
实部 a: 5
虚部 a: 6
加法: (8+10i)
减法: (2+2i)
乘法: (-9+38i)
除法: (1.56-0.08i)
```



### 1.4 布尔型

:::tip 说明

布尔型数据在go语言中以 `bool` 类型进行声明，布尔型数据只有 `true(真)` 和 `false(假)` 两个值

:::

代码示例

```go
package main

import "fmt"

func main() {
	var b1 bool = true
	var b2 bool = false

	fmt.Printf("布尔类型示例：\n")
	fmt.Printf("b1 && b2: %v\n", b1 && b2)
	fmt.Printf("b1 || b2: %v\n", b1 || b2)
	fmt.Printf("!b1: %v\n", !b1)
}
```

输出

```
布尔类型示例：
b1 && b2: false
b1 || b2: true
!b1: false
```



### 1.5 字符串

:::tip 说明

字符串在go语言中以原生数据类型出现，使用字符串就像使用其他原生数据类型(int、bool、float32、float64等)一样

:::

#### 1.5.1 字符串转义符

| 转义符 | 说明                             |
| ------ | -------------------------------- |
| `\r`   | 回车符(返回首行)                 |
| `\n`   | 换行符(直接跳到下一行的同列位置) |
| `\t`   | 制表符                           |
| `\'`   | 单引号                           |
| `\"`   | 双引号                           |
| `\\`   | 反斜杠                           |



代码示例

```go
package main

import "fmt"

func main() {
	fmt.Println("str := \"c:\\Go\\bin\\go.ext\"")
}
```

输出

```shell
str := "c:\Go\bin\go.ext"
```



#### 1.5.2 定义字符串

定义单行

```go
str := "hello world"
ch := "我尼玛？"
```



定义多行

```go
str := ` 第一行
第二行
第三行
\r\n
	 `
```

输出

:::tip 说明

两个反引号间的字符串将被原样赋值到 `str` 变量中，在这种方式下，反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出

:::

```shell
 第一行
        第二行
        第三行
        \r\n
```



#### 1.5.3 字符

字符串中的每一个元素叫做字符，go语言的字符有以下两种

- `uint8` 类型，也叫 `byte` 型，代表了 `ASCII` 码的一个字符

- `rune` 类型，代表一个 `utf-8` 字符，当需要处理中文或其他符合字符时，则需要用到 `rune` 类型，`rune` 类型实际是一个 `int32`



:::tip 说明

使用 `fmt.Printf` 中的 `%T` 可以输出变量的实际类型，使用这个方法可以查看 `byte` 和 `rune` 的本来类型

`%d` 是输出字符的整数值(十进制格式)

`%T` 是输出字符的类型

:::

代码示例

```go
package main

import "fmt"

func main() {
	var a byte = 'a'
	fmt.Printf("%d %T\n", a, a)

	var b rune = '我'
	fmt.Printf("%d %T\n", b, b)
}
```

输出

```shell
97 uint8
25105 int32
```





## 2.复合数据类型

### 2.1 数组 `array`

#### 2.1.1 说明

:::tip 说明

- 数组是指一系列同一类型数据的集合
- 数组中包含的每个数据被称为数组元素(element)，这种类型可以是任意的原始类型，例如 `int` 、`string` 等
- 一个数组包含的元素个数被称为数组的长度
- 数组是一个长度固定的数据类型，数组的长度是类型的一部分，`[5]int` 和 `[10]int` 是不同的类型

:::



#### 2.1.2 定义方式

:::tip 说明

- 数组的长度必须是常量，并且长度是数组的类型的一部分
- 数组一旦定义，长度不可变，元素可变

:::

```go
var 数组名称 [元素数量]类型
```



- 方式1 指定长度和类型

  ```go
  var arr [5]int // 长度为5的int数组，初始值为[0, 0, 0, 0, 0]
  ```

- 方式2 指定长度和类型同时初始化

  ```go
  arr := [5]int{1, 2, 3, 4, 5} // 长度为5，初始值为[1, 2, 3, 4, 5]
  ```

- 方式3 使用 `...` 让编译器自动推断长度

  ```go
  arr := [...]int{1, 2, 3} // 自动推断长度为3
  ```

  

代码示例

```go
package main

import "fmt"

func main() {

	// 定义一个长度为5，类型为int的空数组
	var a [5]int

	// 定义一个长度为3，类型为int的数组并赋值
	var b [3]int
	b[0] = 80
	b[1] = 90
	b[2] = 100

	// 定义一个长度为3，类型为int的数组并赋值
	c := [3]int{1, 2, 3}

	fmt.Println("a:", a)
	fmt.Println("b:", b)
	fmt.Println("c:", c)
}
```

输出

```shell
a: [0 0 0 0 0]
b: [80 90 100]
c: [1 2 3]
```



#### 2.1.3 使用示例

**普通遍历数组**

```go
package main

import "fmt"

func main() {

	var a = [5]string{"北京", "上海", "广州", "深圳", "杭州"}
	for i := 0; i < len(a); i++ {
		fmt.Println(a[i])
	}
}
```

输出

```shell
北京
上海
广州
深圳
杭州
```



**`k`,`v` 遍历数组**

```go
package main

import "fmt"

func main() {
	var a = [5]string{"北京", "上海", "广州", "深圳", "杭州"}
	for index, value := range a {
		fmt.Println(index, value)
	}
}
```

输出

```shell
0 北京
1 上海
2 广州
3 深圳
4 杭州
```



### 数组与切片的区别

| 特性               | 数组                            | 切片                     |
| ------------------ | ------------------------------- | ------------------------ |
| 长度是否固定       | 固定                            | 可变                     |
| 定义时是否需要长度 | 必须指定长度（或用 `...` 推断） | 不需要，直接用 `[]` 定义 |
| 是否值类型         | 是（传递时会拷贝整个数组）      | 否（传递的是引用）       |
| 初始化方式         | `[n]type{...}`                  | `[]type{...}`            |
| 使用 `make` 创建   | 不支持                          | 支持                     |
| 底层结构           | 直接存储元素                    | 基于数组，提供灵活操作   |



### 2.2 切片 `slice`

#### 2.2.1 说明

:::tip 说明

切片是一个拥有 **相同类型元素** 的 **可变长度** 的序列

:::



#### 2.2.2 定义方式

:::tip 说明

`T` 代表切片元素类型，可以是整型、浮点型、布尔型、切片、map、函数等

切片的元素使用 `[]` 进行访问，在方括号中提供切片的索引即可访问元素，索引的范围从0开始，且不超过切片的最大容量

:::

```go
var name []T
```



- 方式1 使用 `make` 创建

  ```go
  slice := make([]int, 5) // 创建长度为5的切片，初始值为[0, 0, 0, 0, 0]
  ```

- 方式2 直接初始化

  ```go
  slice := []int{1, 2, 3} // 创建切片并初始化
  ```

- 方式3 从现有数组中创建切片

  ```go
  arr := [5]int{1, 2, 3, 4, 5}
  slice := arr[1:4] // 从数组的第2到第4个元素生成切片
  ```

  





#### 2.2.3 使用示例



```go

```



### 2.3 字典 `map`



### 2.4 结构体 `struct`



### 2.5 接口 `interface`



### 2.6 通道 `channel`



### 2.7 指针 `pointer`

#### 2.7.1 说明

:::tip 说明

指针概念在go语言中被拆分为2个核心概念

- 类型指针，允许对这个指针类型的数据进行修改，传递数据使用指针，而无须拷贝数据，类型指针不能进行偏移和运算
- 切片，由指向起始元素的原始指针、元素数量和容量组成

:::



#### 2.7.2 定义方式

##### 2.7.2.1 指针类型声明

:::tip 说明

指针类型用 `*` 表示，指向某种类型的变量

:::

```go
var ptr *int // 指向一个 int 类型的指针
```



通过 `new()` 函数创建

```go
new(类型)
```



```go
package main

import "fmt"

func main() {
	str := new(string)
	*str = "我尼玛"
	fmt.Println(*str)
}
```

输出

```shell
我尼玛
```



##### 2.7.2.2 获取指针地址

:::tip 说明

使用 `&` 操作符获取变量的地址

:::

```go
var a int = 10
var ptr *int = &a // 将 a 的地址赋值给 ptr
```



##### 2.7.2.3 通过指针访问值

:::tip 说明

使用 `*` 操作符（解引用）访问指针指向的变量

:::

```go
fmt.Println(*ptr) // 输出 a 的值，即 10
```





#### 2.7.3 使用示例

##### 2.7.3.1 指针地址和指针类型

:::tip 说明

每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置，go语言中使用 `&` 操作符放在变量前边对变量进行 **取地址** 操作，格式如下

```go
ptr := &v // v的类型为T
```

其中 `v` 代表被取地址的变量，被取地址的 `v` 使用 `ptr` 变量进行接收，`ptr` 的类型就为 `*T` ，称作 `T` 的指针类型，`*` 代表指针

:::



获取变量取地址后的指针值

```go
package main

import "fmt"

func main() {
	var cat int = 1
	var str string = "hahaha"

	fmt.Printf("%p %p", &cat, &str)
}
```

输出

:::tip 说明

- 输出值在每次运行是不同的，代表 `cat` 和 `str` 变量取地址后的指针值，指针值带有 `0x` 的十六进制前缀

- 变量、指针和地址三者的关系是：每个变量都拥有地址，指针的值就是地址

:::

```shell
0x14000098020 0x1400008e170
```



##### 2.7.3.2 从指针获取指针指向的值

:::tip 说明

在对普通变量使用 `&` 操作符取地址获得这个变量的指针后，可以对指针使用 `*` 操作，也就是指针取值

:::



```go
package main

import "fmt"

func main() {
	// 准备一个字符串类型
	var house = "北京市朝阳区将台路666号"

	// 对字符串取地址，ptr类型为 *string
	ptr := &house

	// 打印ptr的类型
	fmt.Printf("ptr type: %T\n", ptr)

	// 打印ptr的指针地址
	fmt.Printf("ptr address: %p\n", ptr)

	// 对指针进行取值操作
	value := *ptr

	// 取值后的类型
	fmt.Printf("value type: %T\n", value)

	// 指针取值后就是指向变量的值
	fmt.Printf("value: %s\n", value)
}
```

输出

:::tip 说明

取地址操作符 `&` 和取值操作符 `*` 是一对互补操作符，`&` 取出地址，`*` 根据地址取出地址指向的值

变量，指针地址、指针变量、取地址、取值的相互关系和特性如下

- 对变量进行取地址(`&`)操作，可以获得这个变量的指针变量
- 指针变量的值就是指针地址
- 对指针变量进行取值(`*`)操作，可以获得指针变量指向的原变量的值

:::

```shell
ptr type: *string
ptr address: 0x1400008e170
value type: string
value: 北京市朝阳区将台666号
```



##### 2.7.3.3 使用指针修改值

:::caution 注意

- `*` 操作符作为右值时，意思是取指针的值；作为左值时，也就是放在赋值操作符的左边时，表示a指向的变量
- `*` 操作符的根本意义就是操作指针指向的变量
  - 当操作在右值时，就是取指向变量的值
  - 当操作在左值时，就是将值设置给指向的变量

:::

```go
package main

import "fmt"

// 交换函数
func swap(a, b *int) {
	// 取a指针的值，赋给临时变量t
	t := *a

	// 取b指针的值，赋给a指针指向的变量
	*a = *b // 这里的 *a 是a指向的变量，不是取a指针的值

	// 将a指针的值赋给b指针指向的变量
	*b = t
}

func main() {
	// 准备2个变量，赋值1和2
	x, y := 1, 2

	// 交换变量值
	swap(&x, &y)

	// 输出变量值
	fmt.Println(x, y)
}
```

输出

```shell
2 1
```





